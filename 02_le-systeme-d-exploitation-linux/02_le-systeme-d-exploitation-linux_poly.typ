#import "@local/it-course:0.1.0" : *
#import "@preview/sourcerer:0.2.1": code

#show: chapter.with(
  subject: "Système 1",
  subject-subtitle: "Découverte de linux",
  topic: "Chapitre 2",
  subtitle: "Le système d'exploitation Linux",
  illustration: image("./couverture.png", width: 14cm),
  author: "Guillaume BITON",
  credit: "Droits d'exploitations accordés à l'ECE",
  licence: [Ce document est protégé par la licence CC BY-NC 4.0 https://creativecommons.org/licenses/by-nc/4.0/)],
  version: "1.1",
  lang: "fr",
  logo: image("../.assets/gbweb-ece.png", width: 9cm)
)

#heading(level: 1, numbering: none)[INTRODUCTION]

Au cours du chapitre précédent, nous avons étudié dans les grandes lignes le rôle, les objectifs et les grands concepts derrière la notion de *Système d'Exploitation*. Dans ce chapitre, nous allons enfin parler de GNU/Linux, découvrir ses caractéristiques et ses spécificités, et essayer de comprendre pourquoi ce Système d'Exploitation est si important de l'univers de l'informatique.

#pagebreak()

= Historique

#info()[
  == Rappels de l'épisode précédent
  Fin des années 60, les géniaux Ken Thompson et Dennis Ritchie créent un système d'exploitation révolutionnaire nommé *UNIX*. La quasi-totalité des Systèmes d'Exploitations que nous connaissons aujourd'hui descendent d'UNIX.

  UNIX est génial, mais il a un défaut : il appartient à AT&T et ces derniers mettent de plus en plus de contraintes à son utilisation.

  Dans les années 80, Richard Stallman lance le projet "GNU" qui vise à proposer un clone libre et gratuit d'UNIX. Il développe rapidement un grand nombre de programmes, mais le noyau tarde à venir.

  Dans les années 90, Linus Torvalds crée le noyau Linux. Ce noyeau se combine parfaitement avec les programmes écrits par Richard Stallman : GNU/Linux est né.
]


#align(
  center,
  figure(
    image("./illustrations/04_linux-announcement.jpeg", width: 14cm),
    caption: [Annonce de Linus Torvalds sur la liste de diffusion des utilisateurs de Minix le 25 août 1991],
  )
)
#pagebreak()

= Caractéristiques

Linux est un Système d'Exploitation :
- *Multitâche* ce qui signifie qu'il permet d'exécuter plusieurs programmes en même temps (en répartissant l'usage des ressources dans le temps).
- *Multiutilisateur* : plusieurs utilisateurs peuvent utiliser la machine, et le système d'exploitation en même-temps (#link(<multiutilisateur>)[voir l'encart ci-après]).
- *Multiplateforme* : il peut fonctionner sur tous types d'ordinateurs, et notamment de CPUs.
- *Libre et Open Source* ce qui veut dire que n'importe qui peut s'en servir comme il le souhaite, de le modifier, de le redistribuer... il appartient à tout le monde et son code source est accessible à tous.
- Compatible POSIX (#link(<posix>)[voir l'encart ci-après])


#idea()[
  Peut-être vous demandez-vous comment un système d'exploitation peut-être multi-utilisateur.
  En effet, les ordinateurs que l'on utilise au quotidien sont équipés d'un écran, d'un clavier et d'une souris... Ce qui ne permet pas de s'en servir à plusieurs en même-temps.

  Mais depuis les tous débuts de l'informatique, et encore (très largement) aujourd'hui, il est très courant d'utiliser des ordinateurs au travers de *terminaux*. \
  Dans le chapitre 1, la figure 1 vous montre la console (et le terminal) d'un IBM360/50. A l'époque, les ordinateurs étaient des monstres qui occupaient des (grandes) pièces entières, et qui produisaient énormément de chaleur et de bruit. On avait l'habitude de place dans une pièce à part des "consoles utilisateurs" constituées le plus souvent de claviers et d'imprimantes (des téléprinteurs) qui permettaient aux utilisateurs d'interagir avec l'ordinateur. Si ce dernier était équipé d'un Système d'Exploitation multi-utilisateurs, il était tout à fait possible de connecter plusieurs terminaux à l'ordinateur pour que plusieurs utilisateurs puissent l'utiliser en même-temps.

  Cette notion de *terminal* est encore très importante aujourd'hui, particulièrement dans le monde UNIX, et nous y reviendrons.
] <multiutilisateur>

#idea()[
  POSIX (Portable Operating System Interface... le X vient de "UniX") est un ensemble de normes définies par l’organisme IEEE (Institute of Electrical and Electronics Engineers). Le but de POSIX est de garantir que les logiciels écrits pour un système d’exploitation compatible POSIX puissent être compilés et exécutés sans modification sur un autre système d’exploitation également compatible POSIX.

  En d'autres termes, un programme respectant POSIX pourra fonctionner sur n'importe quel Système d'exploitation compatible POSIX.
] <posix>

Linux propose :
- Un système de fichiers hiérarchique : une manière de "ranger" les fichiers que vous connaissez bien, sous forme d'*arborescence* : on créée des répertoires dans des répertoires (les branches de l'arbre) pour y placer les fichiers (les feuilles de l'arbre).
- Des *processus hiérarchisés*. Linux représente chaque tâche à effectuer sous la forme d'un processus. Les processus ont tous un processus parent (à l'exception du processus "init", le plus haut dans la hiérarchie) et peuvent avoir des processus enfants _(pas de panique : ce sont des notions que l'on abordera en surface et en fin de cours)_.
- Des *threads* ou "fils d'exécution" : des "sous-processus" qui partagent la mémoire virtuelle du processus parent _(pas de panique : ce sont des notions que l'on abordera en surface et en fin de cours)_.
- Une *interface interactive (le shell)* : c'est ce qui va occuper l'essentiel de notre cours, nous y reviendrons longuement et en détail.
- De nombreux *mécanismes de protection* en natif (et plus encore par ajout de modules).
- La gestion du *multiprocesseur* : dès 1958 certains ordinateurs sont équipés de plusieurs CPUs (dans les années 2000 apparaitront les processeurs multicoeurs, et il n'est aujourd'hui pas rare de voir des machines équipées de plusieurs processeurs multicoeurs) et Linux est nativement capable de le gérer.
- ... et bien d'autres choses

#pagebreak()

= Philosophie

Linux repose sur de grands principes parmi lesquels :
- *Tout est fichier* : vous m'entendrez souvent revenir sur ce principe fondamental.
L'implication profonde de ce postulat peut être complexe à appréhender et dépassera rapidement le cadre de ce cours, mais ce qu'il est important de retenir est que, dans le monde Linux, nous aimons tout représenter sous la forme de fichiers.
- *Portabilité* : Linux se veut universel et quand on contribue à Linux, on doit avoir en tête que notre code doit pouvoir fonctionner sur l'ordinateur de sa grand-mère, un super-calculateur de la Nasa ou bien une montre connectée.
- *Ne faire qu’une chose et le faire bien.*
  Dans le monde linux, on cherche à faire des programmes qui ne font qu'une chose mais qui la font bien. Cela inspirera très fortement les architectures "micro-services".
- KISS : Keep It Stupid Simple
  Le fonctionnement d'un programme doit être simple. C'est le meilleur moyen de le rendre robuste... et qu'il soit correctement intégré par la communauté.

#quotebox(author: [Dennis Ritchie])[
  UNIX is basically a simple operating system, but you have to be a genius to understand the simplicity.
]
Soit :
#quotebox(author: [Dennis Ritchie])[
  UNIX est un système d'exploitation simple, mais il faut du génie pour comprendre sa simplicité.
]

#quotebox(author: [Steven King])[
  Unix is user-friendly.
  It just isn't promiscuous about which users it's friendly with. 
]
Soit :
#quotebox(author: [Steven King])[
  UNIX est convivial.
  Il ne l'est juste pas avec tout le monde.
]

#pagebreak()

= Les distributions

Il existe une grande quantité de *distributions* Linux.

Une distribution est un "package" constitué d'un noyau Linux et d'une sélection d'applications (en lignes de commandes, et/ou graphiques).

La plupart des distributions sont elles-mêmes basées sur d'autres distributions.

Par exemple, la distribution "Ubuntu", de loin la plus populaire pour le grand-publique est basée sur "Debian".
Ubuntu rencontre un immense succès car elle est très accessible : son installation est simple, elle contient suffisamment de drivers pour être compatible de tous les ordinateurs du commerce, récents comme anciens, et embarque un environnement de bureau graphique simple et performant qui la rend très facile à prendre en main pour des gens habitués à Windows ou MacOS.

Dans le monde professionnel, on trouve beaucoup de distributions Linux... payantes et propriétaires. Ainsi, Red Hat domine le marché des distributions Serveur. Nous en reparlerons.

#pagebreak()

= De l'importance de Linux

Si vous vous demandez pourquoi dédier un module entier à Linux, voici quelques éléments de réponse.

Tout d'abord, je serai tenté de vous dire que Linux n'est rien d'autre que le meilleur système d'exploitation de tous les temps... mais je manquerai sans doute d'objectivité.

Ensuite, je vous dirai que maîtriser Linux revient à maîtriser UNIX... et donc le système d'exploitation à la base de presque tout dans l'industrie.
- 70% des serveurs web dans le monde sont sous Linux. Les serveurs hautement critiques (de banques, d'assurances, de services d'états...) sont sous des dérivés d'UNIX comme AIX par exemple.
- 100% des supercalculateurs dans le monde sont sous Linux.
- Votre box internet, votre smartphone Android, votre Smart-TV… sont sous Linux.
- Tous les appareils connectés que vous connaissez sont soit sous Linux, soit sous des dérivés d'UNIX.
- Les systèmes embarqués (dans votre voiture, dans les trains, les avions, les satellites...) tournent la plupart du temps sous des dérivés d'UNIX quand ce n'est Linux lui-même.

Enfin *100% des bons informaticiens maitrisent Linux*.

Linux est tellement important dans l'industrie que, depuis quelques années, Microsoft lui-même (souvenez-vous que Windows est à peu près le seule Système d'Exploitation à ne pas dériver d'UNIX) investit énormément d'argent et de ressources dans son développement et son intégration dans Windows.

#pagebreak()

= De l'importance du libre

En 1980, Richard M. Stallman (le créateur de GNU) travaille au MIT. Il a "bidouillé" l'énormissime imprimante de son département (tellement encombrante et bruyante qu'elle avait été installée à un étage différent des bureaux) pour qu'elle envoie une alerte aux utilisateurs lorsque leurs documents ont fini leur impression, ou qu'elle rencontre un problème : tout le monde en est très content.

Mais le département achète une nouvelle imprimante... et le code source de cette dernière est "fermé" et propriétaire. Résultat : impossible de la bidouiller pour lui ajouter cette fonctionnalité pourtant si pratique.

Richard Stallman a une illumination : le code fermé et propriétaire résulte en des programmes plus contraignants, souvent moins bien... et les utilisateurs ont l'impossibilité de l'améliorer eux-mêmes ou de l'adapter à leur besoin.

Il devient alors un pionnier, et un fervent défenseur du libre.

Aujourd'hui encore, dans l'industrie, on me fait souvent la réflexion "mais tu es sûr qu'on ne ferait pas mieux d'investir dans une solution propriétaire ? On a quand même la production de clients qui tourne sur nos systèmes, et des responsabilités. En cas de problème j'aimerai autant qu'on puisse se tourner vers le support du fournisseur, quitte à payer des dizaines de milliers d'euros par an.". J'ai mainte et mainte fois prouvé que ce raisonnement (poussé par les commerciaux) est totalement biaisé. J'ai souvent fait face à des constructeurs qui, bien que vendant des systèmes extraordinairement chers et vendant, en plus, un support hors de prix nous laisse seuls face à un problème, après avoir laissé trainer les choses le plus longtemps possible (en nous faisant faire et refaire une série incroyable de tests tous plus incohérents les uns que les autres). A la fin, on se retrouve avec un système qui ne fonctionne pas, beaucoup de temps perdu et, du fait de la fermeture du code... l'impossibilité de résoudre le problème soi-même.

Avec le libre, non seulement on a la possibilité de corriger soi-même et d'adapter le code à sa problématique, mais, en plus, il suffit généralement d'un "issue" posté sur GitHub ou d'un message sur un forum pour que toute l'équipe de mainteneurs du code se mette en branle et résolve le problème en quelques heures.

Enfin, à l'heure où les problématiques de cyber-sécurité sont omniprésentes, l'ouverture du code-source prend toute son importance.
Des dizaines de milliers de hacker éthiques passent leurs journées à scruter le code source des logiciels libres pour y déceler des failles et les corriger. Quand un hacker malveillant exploite une faille, la communauté propose généralement un correctif dans les heures qui suivent.

Avec les logiciels propriétaires, il n'est pas rare que des failles de sécurité mettent des mois voir des années à être découvertes... et il arrive même que, plutôt que d'alerter sur leur risque et d'appeler à l'aide pour la corriger, les entreprises propriétaires cachent le plus longtemps possible cette faille, quitte à mettre ses clients en danger.

#pagebreak()


#bibliography("./bib.yml", style: "ieee", full: true)