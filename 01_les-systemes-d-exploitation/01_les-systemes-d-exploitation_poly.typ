#import "@local/it-course:0.1.0" : *
#import "@preview/sourcerer:0.2.1": code

#show: chapter.with(
  subject: "Système 1",
  subject-subtitle: "Découverte de linux",
  topic: "Chapitre 1",
  subtitle: "Les systèmes d'exploitation",
  illustration: image("./couverture.png", width: 15cm),
  author: "Guillaume BITON",
  credit: "Droits d'exploitations accordés à l'ECE",
  licence: [Ce document est protégé par la licence CC BY-NC 4.0 https://creativecommons.org/licenses/by-nc/4.0/)],
  version: "1.0",
  lang: "fr",
  logo: image("../.assets/gbweb-ece.png", width: 9cm)
)


#heading(level: 1, numbering: none)[INTRODUCTION]

Au cours du chapitre précédent, nous avons étudié dans les grandes lignes le fonctionnement d'un ordinateur. Nous avons vu que ce dernier est constitué d'un CPU (dont nous avons un peu approfondi le fonctionnement), de mémoires et de périphériques d'entrées/sorties.
Nous avons également vu qu'il est possible de coder en assembleur, en écrivant des instructions très précises qui seront directement exécutées (telles-quelles) par le CPU. Nous avons commencé à aborder les notions de langages de programmations qui permettent d'une part de rendre l'écriture de programmes plus "accessible" pour les êtres humains que nous sommes et d'autre part d'écrire des programmes capables d'être exécutés sur différents types de CPUs.

Dans ce chapitre, nous allons découvrir la notion de système d'exploitation, et comprendre pourquoi ces programmes d'un type très particulier sont essentiels pour tirer la quintessence de nos ordinateurs... sans être doctorant en informatique.

#pagebreak()

= Définition

Un _Système d'Exploitation_ ("_SE_") ou "_OS_" (pour "_Operating System_") est avant tout un (très gros) programme informatique ou, plus précisément un ensemble de programmes informatiques. \
On le classe dans la catégorie des programmes systèmes (c'est à dire qui n'a pas vocation à être directement utilisé par un humain, qui ne permet pas à l'utilisateur d'effectuer une tâche spécifique, mais qui permet au système informatique de fonctionner correctement). \
Il sert d'interface entre la machine, l'utilisateur et les différents programmes d'applications (c'est à dire les programmes dont se sert "directement" l'utilisateur).
#align(
  center,
  image("./illustrations/01_diagramme.png", width: 12cm),
)

= Objectif

Le _système d'exploitation_ permet d'utiliser (beaucoup) plus *facilement* et *efficacement* l'ordinateur.
Dans les années 40 et le début des années 50, les ordinateurs (comme le _Harvard Mark I_ ou l'_ENIAC_ - voir chapitre 0) ne disposaient pas de système d'exploitation. On écrivait un programme en assembleur directement pour la machine, et ce programme devait gérer tous les éléments du système de sa mise en marche à son extinction.

Revenons à l'analogie des artisans en bâtiment du chapitre précédent.
Imaginez que vous avez à votre disposition une équipe d'ouvriers : ce sont vos différents processeurs (CPU, GPU, ...). Lors du précédent chapitre, nous avons vu que coder en assembleur revenait à devoir leur dicter un à un chaque geste à effectuer (et je parle de geste comme "avancer une main", "refermer les doigts", "lever un pied" ...). Nous avons vu que cela rendait l'écriture d'un programme informatique très complexe. Mais nous n'avons pas abordé la question des interactions des ouvriers entre eux, leurs interactions avec leur environnement et même... leur propre gestion.
Ainsi, imaginez que pour coder le programme "construire une maison" vous deviez non seulement décrire aux ouvriers chaque micro-geste qu'ils doivent effectuer pour construire la maison elle-même, mais également pour se nourrir, se reposer, aller aux toilettes... Et que vous deviez coordonner le travail de toute l'équipe en fonction de leurs tâches respectives, mais également en fonction des approvisionnements en matériaux (parpaings, béton, placo...). Dans ces conditions, construire la moindre petie bicoque deviendrait un casse-tête absolument infernal. Imaginez tout ce à quoi vous devriez penser pour que votre couvreur ne commence pas à faire la charpente alors que le maçon n'a même pas commencé les murs, que votre peintre ne perde pas son temps à repasser sur les murs avec un pinceau tout sec car vous avez oublié de le faire s'approvisionner en peinture, que l'électricien ne s'écroule d'inanition car vous ne lui avez pas dit de se nourrir.

Au bout de très nombreux essais et avec un travail considérable, vous arriverez peut-être à construire une cabane à peu près convenable, mais pour peu qu'on vous change un ouvrier (celui-ci ayant les jambes plus longues que le précédent, il faut revoir tout le code car il lui faut moins de pas pour aller d'un point à un autre) ou même qu'on vous livre une cargaison de béton plus importante que d'habitude (votre code est basé sur le fait qu'il faut faire exactement trente-quatre allers-retours avec une brouette pour le vide, mais cela ne s'applique plus) : vous allez devenir fou. \
Et dans ces conditions, impossible d'imaginer construire une maison un peu élaborée, une villa et encore moins un building.

Vous avez donc besoin... d'un *système d'exploitation*.

Dans notre exemple, le système d'exploitation se chargera de tout :
- gérer les ouvriers et leurs besoins primaires (se nourrir, dormir, ...)
- gérer leurs spécificités (celui-ci a de plus grandes jambes, celui-ci ne peint pas au pinceau mais au rouleau...)
- gérer la planification (faire en sorte que le maçon ne reste pas les bras ballants pendant un mois à cause d'une cargaison de parpaings qui n'arrivent pas, alors qu'il pourrait pendant ce temps s'occuper du mur en briques).

La personne en charge de programmer (d'écrire les programmes) voit sa vie immensément simplifiée : il peut se concentrer sur la logique de son programme, et voit les accès aux ressources de l'ordinateurs simplifiés. \
L'utilisateur des programmes, lui aussi, gagne en simplicité : plus besoin d'être un expert de renommée internationale pour se servir d'un ordinateur.

En fait, le système d'exploitation créée de l'*abstraction*. Ce mot est très important pour comprendre le rôle du Système d'Exploitation.
Pour vous donner un exemple concret : sans système d'exploitation, si je veux écrire une donnée en mémoire, il faut que je :
- sélectionne le type de mémoire
- calcule la taille de la donnée (pour savoir de combien d'espace mémoire j'ai besoin)
- trouve une case mémoire libre (et donc que je m'assure que ni moi ni personne d'autre ne s'en sert... ce qui n'est pas une mince affaire)
- écrive dans la mémoire
Si un jour on ajoute de la mémoire à la machine, il faudra réécrire le programme pour qu'il en tire partie. \
En d'autres termes, il faut que je connaisse tous les rouages de la machine, car je dois les actionner moi-même.

Avec le système d'exploitation entre mon programme et ma machine, je peux simplement demander à l'OS "écrit cette donnée en mémoire" et il se chargera de toute la mécanique que cela suppose.
En cela, il créée de l'abstraction : il me propose des concepts de plus haut niveau avec lesquels interagir que la réalité brute et complexe de la machine.

Pour ce faire, on dit que le Système d'Exploitation met à notre disposition une *machine virtuelle*, c'est à dire une vision simplifiée et universelle de l'ordinateur. On interagit avec cette machine virtuelle au travers d'*appels systèmes*.

Par exemple, le système d'exploitation nous expose "une mémoire". Pas besoin de savoir quel est son type, sa taille, sa vitesse, son mode d'écriture, le nom de ses registres... on a une mémoire à disposition, et c'est tout ce qu'on a besoin de savoir.

Enfin, le système d'exploitation est en charge de l'allocation et de la gestion des ressources, ainsi que de ce qu'on appelle *l'ordonnancement*. Il fait en sorte que l'on puisse exploiter les ressources (et notamment le CPU) de manière optimale. \
L'immense majorité des systèmes d'exploitation sont dits "multitâches" et "multi-utilisateurs", c'est à dire que plusieurs utilisateurs peuvent s'en servir simultanément et surtout faire plusieurs choses en même temps. \
Pour accomplir cela (il n'y a après tout qu'un seul CPU dans nos machines), il répartit le temps processeur entre les différents programmes. Ainsi, le programme A va pouvoir se servir du CPU pendant quelques millisecondes, puis l'OS le mettra en pause pour laisser le programme B se servir du CPU, et ainsi de suite. Les programmes ne fonctionnent pas tout à fait "en même temps" mais ils se passent le relai à une telle vitesse que, pour un utilisateur humain, cela revient au même.
L'ordonnancement est une responsabilité loin d'être anecdotique pour l'OS : les programmes ont besoin de temps CPU, mais également d'accéder aux différentes mémoires, aux périphériques d'entrées/sorties... Un bon OS est capable de gérer l'allocation des ressources de manière optimale en prenant en compte toutes ces contraintes (par exemple, il ne sert à rien de continuer à réserver du temps processeur à un programme qui est "bloqué" tant que l'utilisateur n'appuie pas sur une touche du clavier, ou qui attend que l'imprimante lui réponde : autant, pendant ce temps, laisser la place aux autres programmes).

Pour reprendre (une dernière fois) l'analogie des ouvriers en bâtiment, vous pouvez imaginer la construction d'une maison sans chef de chantier : le premier jour, tout le monde arrive sur le chantier... mais les fondations ne sont pas encore coulées, donc innutile de dire que la présence de l'électricien et du plombier ne sera pas nécéssaire avant plusieurs semaines. Alors tout le monde rentre chez lui, mais quand les fondations sont coulées, plus personne n'est là pour commencer à faire les murs... On fait revenir le maçon, mais à peine a-t-il commencé à poser la première brique que le peintre se présente pour les peintures du finition ! Résultat : il vous faudra des années pour construire la maison, et le temps des ouvriers sera très, très mal utilisé : ils seront mobilisés pendant des mois et des mois pour n'être utiles que quelques jours en tout.
Avec un bon chef de chantier (un bon système d'exploitation), on s’arrangera pour que le peintre commence une pièce dès que le plaquiste l'a terminé, que l’électricien travaille dans le salon pendant que le plombier fait la cuisine etc… Si une livraison arrive en retard, on replanifiera tout au jour le jour pour exploiter au mieux toutes les ressources disponibles.
Ainsi, non seulement notre maison sera finie en quelques semaines mais, en plus, les ouvriers pourront mener d'autres chantiers en parallèle !
Merci, le système d'exploitation :-)

#info()[
  Aujourd’hui, dans le grand-public, on parle de Système d’Exploitation pour désigner des suites logicielles entières. \
  Une distribution GNU/Linux grand-public, Windows ou Mac OS intègrent de très nombreux outils qui permettent la gestion de la sécurité de la machine et de ses utilisateurs, du réseau, du partage de fichiers, de nombreuses taches de bureautique et multimédia (bloc note, calculatrice, visionneuse d’images, lecteur multimédia…). \
  Il est important de garder à l’esprit que ce ne sont rien d’autre que des applications et des services qui sortent du scope ordinaire du système d’exploitation.
]


= Conception

Tout système d’exploitation introduit les notions de *processus* et de *système de fichiers*.

Le "coeur du système", c'est le noyau : c'est lui qui est lancé ("amorcé") au démarrage de l'ordinateur et qui va fournir les différentes couches d'abstraction, l'ordonnancement, les échanges entre les processus et avec le matériel...

Le système d'exploitation fournit à l'utilisateur un (ou des) moyens d'interaction :
- L'interpréteur de commandes (l'utilisateur peut rentrer des commandes sous forme de texte, et l'ordinateur lui répond, sous forme de texte également).
- Une interface graphique (apparue plus récemment, c'est ce que la plupart des gens connaissent avec le bureau, les fenêtres, les lanceurs d'applications... mais n'allez surtout pas penser qu'on n'utilise plus l'interpréteur de commandes !).

= Histoire

Le concept de système d'exploitation apparait fin des années 1950 / début des années 1960.
Loin d'être "universels", les systèmes d'exploitation sont généralement conçus pour une machine donnée.
Par exemple, le système OS/360 d'IBM est souvent cité parmi les premiers OS, notamment car il était novateur a bien des égards, et a rencontré un franc succès.
Il animait les machines IBM de la série System/360 dont nous avons parlé au chapitre précédent (c'est sur ces machines, et avec ce SE que la plupart des calculs ayant permis la réalisation des missions Apollo ont été réalisés).
#align(
  center,
  figure(
    image("./illustrations/03_IBM-360-console.jpg", width: 6cm),
    caption: [Console d'un IBM360/50 grace à laquelle l'utilisateur pouvait interagir avec l'ordinateur],
  )
)

Comme chaque constructeur concevait un système d'exploitation pour (presque) chacun de ses ordinateurs, il y eut rapidement un grand nombre de systèmes d'exploitation.

En 1964, le MIT, les Laboratoires Bell et General Electric (tous trois des géants de l'électronique et de la technologie de pointe) se lancent dans un programme conjoint dans le but de créer un système d'exploitation très ambitieux pour les GE 645 et Honeywell 6000. Ils le baptisent "Multics" pour "MULTiplexed Information and Computing Service". Le multics propose un système de fichiers hiérarchique, une exécution dite « en temps partagé », du multitâche préemptif, une utilisation multi-utilisateurs, des notions de sécurité... En d'autres termes, il est franchement révolutionnaire.

En 1969, Ken Thompson et Dennis Ritchie des laboratoires Bell d’AT&T quittèrent le projet Multics pour lancer Unics (ils choisirent ce nom comme un clin d'oeil : c’est un Multics dont le trop compliqué « multiplexed » est remplacé par « uniplexed »)… Rapidement renommé UNIX.
UNIX était entièrement écrit en Assembleur, jusqu’à ce que Dennis Ritchie invente un nouveau langage... Le C (nous l'avons évoqué au chapitre précédent : le C est tout simplement le langage sur lequel toute l'informatique moderne repose). Cette idée est absolument géniale, car *il suffira ensuite d’écrire un compilateur C pour une machine pour que celle-ci devienne compatible UNIX*.

UNIX est tellement bon que presque tous les systèmes d’exploitation que nous connaissons en sont issus (Linux, bien sûr, mais aussi tous les BSD, AIX, Mac OS, IOS, Android, Chrome OS... sauf MS-DOS et Windows !).
Les sources d’UNIX appartiennent à AT&T et, bien que très libres au début, les conditions d’utilisations se durcissent dans les années 80. En réponse à ce durcissement, des « imitations » commencent à apparaitre.

En 1983, Richard Stallman lance le projet GNU. Le but est de fournir un équivalent d’UNIX uniquement composé de logiciels libres… Mais Hurd, son noyau, traine à être opérationnel (il lui faudra plus de quinze ans pour sortir).
En 1987, Andrew S. Tanenbaum écrit une « copie » simplifiée d’UNIX à des fins éducatives : Minix.

En 1991, Linux Torvalds, un jeune étudiant Finlandais, se base sur Minix pour créer son propre noyau : Linux.
Ce noyau se mariera à merveille à GNU pour former GNU/Linux.

#align(
  center,
  figure(
    image("./illustrations/04_linux-announcement.jpeg", width: 14cm),
    caption: [Annonce de Linus Torvalds sur la liste de diffusion des utilisateurs de Minix le 25 août 1991],
  )
)

#pagebreak()

#bibliography("./bib.yml", style: "ieee", full: true)